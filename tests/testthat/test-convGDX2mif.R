# uncomment to skip test
# skip("Skip GDX test")

# Check REMIND output. dt is a data.table in *wide* format,
# i.e., variables are columns. `eqs` is a list of equations of the form
# list(LHS = "RHS", ...). The scope determines if the equations
# should be checked for regions ("regional"), only globally ("world") or
# both ("all"). Sensitivity determines the allowed offset when comparing
# LHS to RHS
library(dplyr)
library(gdx)

test_that("Test if REMIND reporting is produced as it should and check data integrity", {
  skip_if_not(as.logical(gdxrrw::igdx(silent = TRUE)), "gdxrrw is not initialized properly")

  # add GDXs for comparison here:
  gdxPaths <- NULL

  if (length(gdxPaths) == 0) {
    defaultGdxPath <- file.path(tempdir(), "fulldata.gdx")
    if (!file.exists(defaultGdxPath)) {
      utils::download.file("https://rse.pik-potsdam.de/data/example/remind2_test-convGDX2MIF_fulldata.gdx",
        defaultGdxPath,
        mode = "wb", quiet = TRUE
      )
    }
    gdxPaths <- defaultGdxPath
  }

  # finds for each AMT scenario the most recent, successfully converged GDX,
  # that is no older than 30 days
  .findAMTgdx <- function(gdxPaths = NULL, scenario = NULL) {
    # regex for "%Y-%m-%d_%H.%M.%S" timestamp
    datetimepattern <- "[0-9]{4}-[0-9]{2}-[0-9]{2}_[0-9]{2}\\.[0-9]{2}\\.[0-9]{2}"

    .did_REMIND_finish <- function(path) {
      logpath <- sub("fulldata.gdx$", "full.log", path)
      return(   file.exists(logpath)
             && "*** Status: Normal completion" %in% readLines(logpath,
                                                               warn = FALSE))
    }

    .latest_run_of_scenario <- function(path) {
      # sort by scenario and decreasing time, latest runs come first
      path <- path %>%
        sort(decreasing = TRUE)

      # duplicates are older than the preceding runs
      dup <- duplicated(sub(paste0("_", datetimepattern), "",
                            basename(dirname(path))))

      # everything that is no duplicate is the latest run of that scenario
      return(path[!dup])
    }

    return(c(gdxPaths,
             Sys.glob(paste0("/p/projects/remind/modeltests/remind/output/",
                             scenario, "*/fulldata.gdx")) %>%
               Filter(.did_REMIND_finish, x = .) %>%
               .latest_run_of_scenario()))
  }

  checkPiamTemplates <- function(computedVariables) {
    templates <- c("AR6", "AR6_NGFS", "NAVIGATE", "SHAPE", "ELEVATE")
    for (template in templates) {
      templateVariables <- template %>%
        piamInterfaces::getREMINDTemplateVariables() %>%
        unique() %>%
        deletePlus()
      expect_true(any(computedVariables %in% templateVariables))
      missingVariables <- setdiff(templateVariables, computedVariables)
      if (length(missingVariables) > 0) {
        warning("The following variables are expected in the piamInterfaces package ",
                "for template ", template,
                ", but cannot be found in the reporting generated by ", gdxPath, ":\n ",
                paste(missingVariables, collapse = ",\n "))
      }
    }
  }

  # uncomment to add current calibration gdxes
  # gdxPaths <- c(gdxPaths, Sys.glob("/p/projects/remind/inputdata/CESparametersAndGDX/*.gdx"))
  # uncomment to add debugging example gdx files
  # gdxPaths <- c(gdxPaths, Sys.glob("/p/projects/remind/debugging/gdx-examples/*.gdx"))
  # uncomment to add gdx files from most recent AMT runs
  gdxPaths <- c(gdxPaths, .findAMTgdx(scenario = "SSP2EU-NPi-AMT"))

  numberOfMifs <- 0

  for (gdxPath in gdxPaths) {
    numberOfMifs <- numberOfMifs + 1

    message("Running convGDX2MIF(", gdxPath, ")...")
    mifContent <- convGDX2MIF(gdxPath, gdx_refpolicycost = gdxPath, testthat = TRUE)

    expect_no_warning(checkVariableNames(getNames(mifContent, dim = 3)))

    computedVariables <- deletePlus(getItems(mifContent, dim = 3.3))
    computedVariables <- gsub("\\(\\)", "(unitless)", computedVariables)
    checkPiamTemplates(computedVariables)
    magclass::write.report(
      x = magclass::collapseNames(mifContent),
      file = file.path(tempdir(), paste0(numberOfMifs, ".mif")),
      scenario = paste0(magclass::getItems(mifContent, dim = "scenario"), numberOfMifs),
      model = "REMIND"
    )
  }
  # create a second file, so we can actually check the comparison code
  if (numberOfMifs == 1) {
    numberOfMifs <- numberOfMifs + 1
    magclass::write.report(
      x = magclass::collapseNames(mifContent),
      file = file.path(tempdir(), paste0(numberOfMifs, ".mif")),
      scenario = paste0(magclass::getItems(mifContent, dim = "scenario"), numberOfMifs),
      model = "REMIND"
    )
  }

  message("Checking compareScenarios...")
  myMifs <- file.path(tempdir(), paste0(seq_len(numberOfMifs), ".mif"))
  histMif <- file.path(tempdir(), "historical.mif")
  if (!file.exists(histMif)) {
    utils::download.file("https://rse.pik-potsdam.de/data/example/historical.mif", histMif, quiet = TRUE)
  }

  suppressWarnings(
    capture.output( # Do not show stdout text.
      compareScenarios2(
        mifScen = myMifs,
        mifHist = histMif,
        outputFormat = "pdf",
        outputFile = "cs2_test",
        outputDir = tempdir(),
        sections = 0
      )
    ) # Render only the info section.
  )
  expect_true(file.exists(file.path(tempdir(), "cs2_test.pdf")))
  unlink(tempdir(), recursive = TRUE)
  tempdir(TRUE)
})
